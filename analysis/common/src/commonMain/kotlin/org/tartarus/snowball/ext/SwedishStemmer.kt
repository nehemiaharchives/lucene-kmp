// Generated by Snowball 2.2.0 - https://snowballstem.org/

package org.tartarus.snowball.ext

import org.tartarus.snowball.Among
import org.tartarus.snowball.SnowballStemmer

/**
 * This class implements the stemming algorithm defined by a snowball script.
 *
 * Generated by Snowball 2.2.0 - https://snowballstem.org/
 */
class SwedishStemmer : SnowballStemmer() {
    private val a_0 = arrayOf(
        Among("a", -1, 1),
        Among("arna", 0, 1),
        Among("erna", 0, 1),
        Among("heterna", 2, 1),
        Among("orna", 0, 1),
        Among("ad", -1, 1),
        Among("e", -1, 1),
        Among("ade", 6, 1),
        Among("ande", 6, 1),
        Among("arne", 6, 1),
        Among("are", 6, 1),
        Among("aste", 6, 1),
        Among("en", -1, 1),
        Among("anden", 12, 1),
        Among("aren", 12, 1),
        Among("heten", 12, 1),
        Among("ern", -1, 1),
        Among("ar", -1, 1),
        Among("er", -1, 1),
        Among("heter", 18, 1),
        Among("or", -1, 1),
        Among("s", -1, 2),
        Among("as", 21, 1),
        Among("arnas", 22, 1),
        Among("ernas", 22, 1),
        Among("ornas", 22, 1),
        Among("es", 21, 1),
        Among("ades", 26, 1),
        Among("andes", 26, 1),
        Among("ens", 21, 1),
        Among("arens", 29, 1),
        Among("hetens", 29, 1),
        Among("erns", 21, 1),
        Among("at", -1, 1),
        Among("andet", -1, 1),
        Among("het", -1, 1),
        Among("ast", -1, 1)
    )

    private val a_1 = arrayOf(
        Among("dd", -1, -1),
        Among("gd", -1, -1),
        Among("nn", -1, -1),
        Among("dt", -1, -1),
        Among("gt", -1, -1),
        Among("kt", -1, -1),
        Among("tt", -1, -1)
    )

    private val a_2 = arrayOf(
        Among("ig", -1, 1),
        Among("lig", 0, 1),
        Among("els", -1, 1),
        Among("fullt", -1, 3),
        Among("\u00F6st", -1, 2)
    )

    private val g_v = charArrayOf(
        17.toChar(),
        65.toChar(),
        16.toChar(),
        1.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        0.toChar(),
        24.toChar(),
        0.toChar(),
        32.toChar()
    )

    private val g_s_ending = charArrayOf(
        119.toChar(),
        127.toChar(),
        149.toChar()
    )

    private val g_ost_ending = charArrayOf(
        173.toChar(),
        58.toChar()
    )

    private var I_x = 0
    private var I_p1 = 0

    private fun r_mark_regions(): Boolean {
        I_p1 = limit
        val v_1 = cursor
        val c = cursor + 3
        if (c > limit) {
            return false
        }
        cursor = c
        I_x = cursor
        cursor = v_1
        while (true) {
            if (in_grouping(g_v, 97, 246)) {
                break
            }
            if (cursor >= limit) {
                return false
            }
            cursor++
        }
        while (true) {
            if (out_grouping(g_v, 97, 246)) {
                break
            }
            if (cursor >= limit) {
                return false
            }
            cursor++
        }
        I_p1 = cursor
        if (I_p1 < I_x) {
            I_p1 = I_x
        }
        return true
    }

    private fun r_main_suffix(): Boolean {
        if (cursor < I_p1) {
            return false
        }
        val v_2 = limit_backward
        limit_backward = I_p1
        ket = cursor
        val amongVar = find_among_b(a_0)
        if (amongVar == 0) {
            limit_backward = v_2
            return false
        }
        bra = cursor
        limit_backward = v_2
        when (amongVar) {
            1 -> slice_del()
            2 -> {
                if (!in_grouping_b(g_s_ending, 98, 121)) {
                    return false
                }
                slice_del()
            }
        }
        return true
    }

    private fun r_consonant_pair(): Boolean {
        if (cursor < I_p1) {
            return false
        }
        val v_2 = limit_backward
        limit_backward = I_p1
        val v_3 = limit - cursor
        if (find_among_b(a_1) == 0) {
            limit_backward = v_2
            return false
        }
        cursor = limit - v_3
        ket = cursor
        if (cursor <= limit_backward) {
            limit_backward = v_2
            return false
        }
        cursor--
        bra = cursor
        slice_del()
        limit_backward = v_2
        return true
    }

    private fun r_other_suffix(): Boolean {
        if (cursor < I_p1) {
            return false
        }
        val v_2 = limit_backward
        limit_backward = I_p1
        ket = cursor
        val amongVar = find_among_b(a_2)
        if (amongVar == 0) {
            limit_backward = v_2
            return false
        }
        bra = cursor
        limit_backward = v_2
        when (amongVar) {
            1 -> slice_del()
            2 -> {
                if (!in_grouping_b(g_ost_ending, 105, 118)) {
                    return false
                }
                slice_from("Ã¶s")
            }
            3 -> slice_from("full")
        }
        return true
    }

    override fun stem(): Boolean {
        val v_1 = cursor
        r_mark_regions()
        cursor = v_1
        limit_backward = cursor
        cursor = limit
        val v_2 = limit - cursor
        r_main_suffix()
        cursor = limit - v_2
        val v_3 = limit - cursor
        r_consonant_pair()
        cursor = limit - v_3
        val v_4 = limit - cursor
        r_other_suffix()
        cursor = limit - v_4
        cursor = limit_backward
        return true
    }

    override fun equals(other: Any?): Boolean {
        return other is SwedishStemmer
    }

    override fun hashCode(): Int {
        return SwedishStemmer::class.qualifiedName!!.hashCode()
    }
}
