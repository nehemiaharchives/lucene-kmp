import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.plugins.ExtensionAware
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction

abstract class GenerateUkrainianDictionaryKotlinTask : DefaultTask() {
    @get:InputFile
    abstract val dictFile: RegularFileProperty

    @get:InputFile
    abstract val infoFile: RegularFileProperty

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @TaskAction
    fun generateKotlin() {
        val dict = dictFile.get().asFile
        val info = infoFile.get().asFile
        if (!dict.isFile) {
            throw GradleException("Ukrainian dictionary not found at ${dict.absolutePath}")
        }
        if (!info.isFile) {
            throw GradleException("Ukrainian info not found at ${info.absolutePath}")
        }
        val packageName = "org.gnit.lucenekmp.analysis.uk"
        val outputRoot = outputDir.get()
            .dir(packageName.replace('.', '/'))
            .asFile
        outputRoot.mkdirs()

        fun renderChunk(namePrefix: String, chunkIndex: Int, bytes: ByteArray, start: Int, endExclusive: Int): String {
            val sb = StringBuilder()
            sb.append("private fun ").append(namePrefix).append("Chunk").append(chunkIndex)
                .append("(): ByteArray = byteArrayOf(\n")
            val bytesPerLine = 16
            for (i in start until endExclusive) {
                val localIndex = i - start
                if (localIndex % bytesPerLine == 0) {
                    sb.append("    ")
                }
                sb.append(bytes[i].toInt())
                if (i != endExclusive - 1) {
                    sb.append(", ")
                }
                if (localIndex % bytesPerLine == bytesPerLine - 1 || i == endExclusive - 1) {
                    sb.append("\n")
                }
            }
            sb.append(")\n\n")
            return sb.toString()
        }

        fun writeParts(
            baseName: String,
            bytes: ByteArray,
            maxFileSize: Int = 2_500_000
        ): List<String> {
            val chunkSize = 4096
            val totalChunks = (bytes.size + chunkSize - 1) / chunkSize
            val partNames = mutableListOf<String>()
            var partIndex = 0
            var chunkIndex = 0

            while (chunkIndex < totalChunks) {
                val sb = StringBuilder()
                sb.append("// Auto-generated by generateUkrainianDictionaryKotlin. Do not edit.\n")
                sb.append("package ").append(packageName).append("\n\n")
                val partName = baseName + "Part" + partIndex
                partNames.add(partName)
                val chunkNames = mutableListOf<String>()

                while (chunkIndex < totalChunks) {
                    val start = chunkIndex * chunkSize
                    val endExclusive = minOf(bytes.size, start + chunkSize)
                    val chunkContent = renderChunk(baseName, chunkIndex, bytes, start, endExclusive)
                    if (sb.length + chunkContent.length > maxFileSize && chunkNames.isNotEmpty()) {
                        break
                    }
                    sb.append(chunkContent)
                    chunkNames.add(baseName + "Chunk" + chunkIndex)
                    chunkIndex++
                }

                sb.append("private fun build").append(partName.replaceFirstChar { it.uppercase() })
                    .append("(): ByteArray {\n")
                sb.append("    val parts = arrayOf(\n")
                for (name in chunkNames) {
                    sb.append("        ").append(name).append("(),\n")
                }
                sb.append("    )\n")
                sb.append("    var total = 0\n")
                sb.append("    for (p in parts) total += p.size\n")
                sb.append("    val out = ByteArray(total)\n")
                sb.append("    var pos = 0\n")
                sb.append("    for (p in parts) {\n")
                sb.append("        p.copyInto(out, pos)\n")
                sb.append("        pos += p.size\n")
                sb.append("    }\n")
                sb.append("    return out\n")
                sb.append("}\n")
                sb.append("internal val ").append(partName).append(": ByteArray by lazy { build")
                    .append(partName.replaceFirstChar { it.uppercase() }).append("() }\n")

                val partFile = outputRoot.resolve("UkrainianDictionaryData_${baseName}_${partIndex}.kt")
                partFile.writeText(sb.toString())
                partIndex++
            }
            return partNames
        }

        val dictParts = writeParts("ukrainianDictData", dict.readBytes())
        val infoParts = writeParts("ukrainianInfoData", info.readBytes())

        val main = buildString {
            append("// Auto-generated by generateUkrainianDictionaryKotlin. Do not edit.\n")
            append("package ").append(packageName).append("\n\n")
            fun renderAggregate(name: String, parts: List<String>) {
                val builderName = name.replaceFirstChar { it.uppercase() }
                append("private fun build").append(builderName).append("(): ByteArray {\n")
                append("    val parts = arrayOf(\n")
                for (part in parts) {
                    append("        ").append(part).append(",\n")
                }
                append("    )\n")
                append("    var total = 0\n")
                append("    for (p in parts) total += p.size\n")
                append("    val out = ByteArray(total)\n")
                append("    var pos = 0\n")
                append("    for (p in parts) {\n")
                append("        p.copyInto(out, pos)\n")
                append("        pos += p.size\n")
                append("    }\n")
                append("    return out\n")
                append("}\n")
                append("internal val ").append(name).append(": ByteArray by lazy { build")
                    .append(builderName).append("() }\n")
            }
            renderAggregate("ukrainianDictData", dictParts)
            append("\n")
            renderAggregate("ukrainianInfoData", infoParts)
        }

        outputRoot.resolve("UkrainianDictionaryData.kt").writeText(main)
    }
}

val ukrainianDictFile = rootProject.projectDir
    .resolve("gradle/morfologik/ukranian/ukrainian.dict")
    .normalize()
val ukrainianInfoFile = rootProject.projectDir
    .resolve("gradle/morfologik/ukranian/ukrainian.info")
    .normalize()
val generatedKotlinDir = layout.buildDirectory.dir("generated/morfologik/ukrainian/kotlin")

val generateUkrainianDictionaryKotlin = tasks.register<GenerateUkrainianDictionaryKotlinTask>(
    "generateUkrainianDictionaryKotlin"
) {
    dictFile.set(ukrainianDictFile)
    infoFile.set(ukrainianInfoFile)
    outputDir.set(generatedKotlinDir)
}

afterEvaluate {
    val kotlinExtension = extensions.findByName("kotlin") as? ExtensionAware ?: return@afterEvaluate
    val sourceSets = kotlinExtension.extensions.getByName("sourceSets") as NamedDomainObjectContainer<*>
    val commonMain = sourceSets.getByName("commonMain") as ExtensionAware

    tasks.matching {
        it.name.startsWith("compile") && it.name.contains("Kotlin")
    }.configureEach {
        dependsOn(generateUkrainianDictionaryKotlin)
    }
}
