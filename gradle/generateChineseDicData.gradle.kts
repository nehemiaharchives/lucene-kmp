import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.plugins.ExtensionAware
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.ObjectInputStream

abstract class GenerateChineseDictionaryKotlinTask : DefaultTask() {
    @get:InputFile
    abstract val bigramMemFile: RegularFileProperty

    @get:InputFile
    abstract val coreMemFile: RegularFileProperty

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @TaskAction
    fun generateKotlin() {
        val bigramFile = bigramMemFile.get().asFile
        val coreFile = coreMemFile.get().asFile
        if (!bigramFile.isFile) {
            throw GradleException("Chinese bigram dictionary not found at ${bigramFile.absolutePath}")
        }
        if (!coreFile.isFile) {
            throw GradleException("Chinese core dictionary not found at ${coreFile.absolutePath}")
        }

        val (bigramHashTable, frequencyTable) = ObjectInputStream(bigramFile.inputStream()).use { input ->
            @Suppress("UNCHECKED_CAST")
            val hashes = input.readObject() as LongArray
            val freqs = input.readObject() as IntArray
            hashes to freqs
        }

        val (wordIndexTable, charIndexTable, wordItemCharArrayTable, wordItemFrequencyTable) =
            ObjectInputStream(coreFile.inputStream()).use { input ->
                val wordIndex = input.readObject() as ShortArray
                val charIndex = input.readObject() as CharArray
                @Suppress("UNCHECKED_CAST")
                val wordItems = input.readObject() as Array<Array<CharArray?>?>
                @Suppress("UNCHECKED_CAST")
                val wordFreqs = input.readObject() as Array<IntArray?>
                Quad(wordIndex, charIndex, wordItems, wordFreqs)
            }

        val bigramData = encodeBigram(bigramHashTable, frequencyTable)
        val coreData = encodeCore(wordIndexTable, charIndexTable, wordItemCharArrayTable, wordItemFrequencyTable)

        val packageName = "org.gnit.lucenekmp.analysis.cn.smart.hhmm"
        val outputRoot = outputDir.get()
            .dir(packageName.replace('.', '/'))
            .asFile
        outputRoot.mkdirs()

        fun renderChunk(namePrefix: String, chunkIndex: Int, bytes: ByteArray, start: Int, endExclusive: Int): String {
            val sb = StringBuilder()
            sb.append("private fun ").append(namePrefix).append("Chunk").append(chunkIndex)
                .append("(): ByteArray = byteArrayOf(\n")
            val bytesPerLine = 16
            for (i in start until endExclusive) {
                val localIndex = i - start
                if (localIndex % bytesPerLine == 0) {
                    sb.append("    ")
                }
                sb.append(bytes[i].toInt())
                if (i != endExclusive - 1) {
                    sb.append(", ")
                }
                if (localIndex % bytesPerLine == bytesPerLine - 1 || i == endExclusive - 1) {
                    sb.append("\n")
                }
            }
            sb.append(")\n\n")
            return sb.toString()
        }

        fun writeParts(
            baseName: String,
            bytes: ByteArray,
            maxFileSize: Int = 2_500_000
        ): List<String> {
            val chunkSize = 4096
            val totalChunks = (bytes.size + chunkSize - 1) / chunkSize
            val partNames = mutableListOf<String>()
            var partIndex = 0
            var chunkIndex = 0

            while (chunkIndex < totalChunks) {
                val sb = StringBuilder()
                sb.append("// Auto-generated by generateChineseDictionaryKotlin. Do not edit.\n")
                sb.append("package ").append(packageName).append("\n\n")
                val partName = baseName + "Part" + partIndex
                partNames.add(partName)
                val chunkNames = mutableListOf<String>()

                while (chunkIndex < totalChunks) {
                    val start = chunkIndex * chunkSize
                    val endExclusive = minOf(bytes.size, start + chunkSize)
                    val chunkContent = renderChunk(baseName, chunkIndex, bytes, start, endExclusive)
                    if (sb.length + chunkContent.length > maxFileSize && chunkNames.isNotEmpty()) {
                        break
                    }
                    sb.append(chunkContent)
                    chunkNames.add(baseName + "Chunk" + chunkIndex)
                    chunkIndex++
                }

                sb.append("private fun build").append(partName.replaceFirstChar { it.uppercase() })
                    .append("(): ByteArray {\n")
                sb.append("    val parts = arrayOf(\n")
                for (name in chunkNames) {
                    sb.append("        ").append(name).append("(),\n")
                }
                sb.append("    )\n")
                sb.append("    var total = 0\n")
                sb.append("    for (p in parts) total += p.size\n")
                sb.append("    val out = ByteArray(total)\n")
                sb.append("    var pos = 0\n")
                sb.append("    for (p in parts) {\n")
                sb.append("        p.copyInto(out, pos)\n")
                sb.append("        pos += p.size\n")
                sb.append("    }\n")
                sb.append("    return out\n")
                sb.append("}\n")
                sb.append("internal val ").append(partName)
                    .append(": ByteArray by lazy { build")
                    .append(partName.replaceFirstChar { it.uppercase() }).append("() }\n")

                val partFile = outputRoot.resolve("ChineseDictionaryData_${baseName}_${partIndex}.kt")
                partFile.writeText(sb.toString())
                partIndex++
            }
            return partNames
        }

        val bigramParts = writeParts("bigramDictData", bigramData)
        val coreParts = writeParts("coreDictData", coreData)

        val main = buildString {
            append("// Auto-generated by generateChineseDictionaryKotlin. Do not edit.\n")
            append("package ").append(packageName).append("\n\n")
            fun renderAggregate(name: String, parts: List<String>) {
                val builderName = name.replaceFirstChar { it.uppercase() }
                append("private fun build").append(builderName).append("(): ByteArray {\n")
                append("    val parts = arrayOf(\n")
                for (part in parts) {
                    append("        ").append(part).append(",\n")
                }
                append("    )\n")
                append("    var total = 0\n")
                append("    for (p in parts) total += p.size\n")
                append("    val out = ByteArray(total)\n")
                append("    var pos = 0\n")
                append("    for (p in parts) {\n")
                append("        p.copyInto(out, pos)\n")
                append("        pos += p.size\n")
                append("    }\n")
                append("    return out\n")
                append("}\n")
                append("internal val ").append(name).append(": ByteArray by lazy { build")
                    .append(builderName).append("() }\n")
            }
            renderAggregate("bigramDictData", bigramParts)
            append("\n")
            renderAggregate("coreDictData", coreParts)
        }

        outputRoot.resolve("ChineseDictionaryData.kt").writeText(main)
    }

    private fun encodeBigram(bigramHashTable: LongArray, frequencyTable: IntArray): ByteArray {
        val baos = ByteArrayOutputStream()
        DataOutputStream(baos).use { out ->
            out.writeInt(bigramHashTable.size)
            for (value in bigramHashTable) {
                out.writeLong(value)
            }
            out.writeInt(frequencyTable.size)
            for (value in frequencyTable) {
                out.writeInt(value)
            }
        }
        return baos.toByteArray()
    }

    private fun encodeCore(
        wordIndexTable: ShortArray,
        charIndexTable: CharArray,
        wordItemCharArrayTable: Array<Array<CharArray?>?>,
        wordItemFrequencyTable: Array<IntArray?>
    ): ByteArray {
        val baos = ByteArrayOutputStream()
        DataOutputStream(baos).use { out ->
            out.writeInt(wordIndexTable.size)
            for (value in wordIndexTable) {
                out.writeShort(value.toInt())
            }
            out.writeInt(charIndexTable.size)
            for (value in charIndexTable) {
                out.writeChar(value.code)
            }
            out.writeInt(wordItemCharArrayTable.size)
            for (entry in wordItemCharArrayTable) {
                if (entry == null) {
                    out.writeInt(-1)
                } else {
                    out.writeInt(entry.size)
                    for (word in entry) {
                        if (word == null) {
                            out.writeInt(-1)
                        } else {
                            out.writeInt(word.size)
                            for (ch in word) {
                                out.writeChar(ch.code)
                            }
                        }
                    }
                }
            }
            out.writeInt(wordItemFrequencyTable.size)
            for (entry in wordItemFrequencyTable) {
                if (entry == null) {
                    out.writeInt(-1)
                } else {
                    out.writeInt(entry.size)
                    for (value in entry) {
                        out.writeInt(value)
                    }
                }
            }
        }
        return baos.toByteArray()
    }

    private data class Quad<A, B, C, D>(val first: A, val second: B, val third: C, val fourth: D)
}

val bigramMemFilePath = rootProject.projectDir
    .resolve("gradle/smartcn/bigramdict.mem")
    .normalize()
val coreMemFilePath = rootProject.projectDir
    .resolve("gradle/smartcn/coredict.mem")
    .normalize()
val generatedKotlinDir = layout.buildDirectory.dir("generated/cn/smart/kotlin")

val generateChineseDictionaryKotlin = tasks.register<GenerateChineseDictionaryKotlinTask>("generateChineseDictionaryKotlin") {
    bigramMemFile.set(bigramMemFilePath)
    coreMemFile.set(coreMemFilePath)
    outputDir.set(generatedKotlinDir)
}

afterEvaluate {
    val kotlinExtension = extensions.findByName("kotlin") as? ExtensionAware ?: return@afterEvaluate
    val sourceSets = kotlinExtension.extensions.getByName("sourceSets") as NamedDomainObjectContainer<*>
    val commonMain = sourceSets.getByName("commonMain") as ExtensionAware

    tasks.matching {
        it.name.startsWith("compile") && it.name.contains("Kotlin")
    }.configureEach {
        dependsOn(generateChineseDictionaryKotlin)
    }
}
