package org.gnit.lucenekmp.geo

import org.gnit.lucenekmp.tests.geo.GeoTestUtil
import org.gnit.lucenekmp.tests.util.LuceneTestCase
import kotlin.math.abs
import kotlin.test.Test
import kotlin.test.assertFalse
import kotlin.test.assertTrue
import kotlin.test.assertEquals

class TestTessellator : LuceneTestCase() {

    @Test
    fun testLinesIntersect() {
        val rect = GeoTestUtil.nextBoxNotCrossingDateline()
        assertTrue(
            Tessellator.linesIntersect(
                rect.minLon,
                rect.minLat,
                rect.maxLon,
                rect.maxLat,
                rect.maxLon,
                rect.minLat,
                rect.minLon,
                rect.maxLat
            )
        )
        assertFalse(
            Tessellator.linesIntersect(
                rect.minLon,
                rect.maxLat,
                rect.maxLon,
                rect.maxLat,
                rect.minLon - 1.0,
                rect.minLat,
                rect.minLon - 1.0,
                rect.maxLat
            )
        )
    }

    @Test
    fun testSimpleTessellation() {
        var poly = GeoTestUtil.createRegularPolygon(0.0, 0.0, 100000.0, 100000)
        val inner = Polygon(
            doubleArrayOf(-1.0, -1.0, 0.5, 1.0, 1.0, 0.5, -1.0),
            doubleArrayOf(1.0, -1.0, -0.5, -1.0, 1.0, 0.5, 1.0)
        )
        val inner2 = Polygon(
            doubleArrayOf(-1.0, -1.0, 0.5, 1.0, 1.0, 0.5, -1.0),
            doubleArrayOf(-2.0, -4.0, -3.5, -4.0, -2.0, -2.5, -2.0)
        )
        poly = Polygon(poly.getPolyLats(), poly.getPolyLons(), inner, inner2)
        assertTrue(Tessellator.tessellate(poly, random().nextBoolean()).size > 0)
    }

    @Test
    @LuceneTestCase.Companion.Nightly
    fun testSimpleTessellationAtNight() {
        var poly = GeoTestUtil.createRegularPolygon(0.0, 0.0, 1_000_000.0, 1_000_000)
        val inner = Polygon(
            doubleArrayOf(-1.0, -1.0, 0.5, 1.0, 1.0, 0.5, -1.0),
            doubleArrayOf(1.0, -1.0, -0.5, -1.0, 1.0, 0.5, 1.0)
        )
        val inner2 = Polygon(
            doubleArrayOf(-1.0, -1.0, 0.5, 1.0, 1.0, 0.5, -1.0),
            doubleArrayOf(-2.0, -4.0, -3.5, -4.0, -2.0, -2.5, -2.0)
        )
        poly = Polygon(poly.getPolyLats(), poly.getPolyLons(), inner, inner2)
        assertTrue(Tessellator.tessellate(poly, random().nextBoolean()).size > 0)
    }

    @Test
    fun testLUCENE8454() {
        val geoJson = (
            "{\"type\": \"Polygon\", \"coordinates\": [[[167.8752929333776, -30.078235509309092], " +
                "[167.729078, -30.078368], [167.7288750679411, -29.918443128222044], [167.728949, -30.078598], " +
                "[167.582239, -30.078557], [167.58234527408044, -29.9717026229659], [167.43547018634274, -30.030896196337487], " +
                "[167.43528, -30.078575], [167.288467, -30.078185], [167.28846777961195, -30.078041819512045], " +
                "[167.142089, -30.077483], [167.143635, -29.813199], [167.1450859974141, -29.567345798606294], " +
                "[167.144888, -29.567345], [167.14633281276596, -29.302953194679134], [167.146281, -29.302953], " +
                "[167.147725, -29.036352], [167.292924, -29.036892], [167.2918703799358, -29.301396273146477], " +
                "[167.29192460356776, -29.301396365495897], [167.292964, -29.036798], [167.4380298884901, -29.037250444489867], " +
                "[167.43803, -29.03719], [167.583317, -29.037381], [167.58331697583935, -29.03744011447325], " +
                "[167.7285250024388, -29.037514998454153], [167.728525, -29.03749], [167.873835, -29.037419], " +
                "[167.87383543708486, -29.037703808329873], [168.018612, -29.037121], [168.0186121103674, -29.03714161109612], " +
                "[168.163842, -29.03656], [168.1650939339767, -29.247683610268638], [168.164004, -29.036724], " +
                "[168.309341, -29.036127], [168.3110870459225, -29.30068025473746], [168.311176, -29.30068], " +
                "[168.312472, -29.567161], [168.31243194795024, -29.56716111631554], [168.31443, -29.812612], " +
                "[168.31388505737894, -29.812615143334597], [168.315886, -30.077081], [168.169234, -30.077883], " +
                "[168.16913368505345, -30.06147402418803], [168.169224, -30.077737], [168.022447, -30.078317], " +
                "[168.02181920125142, -29.924959173336568], [168.0221, -30.078254], [167.875293, -30.078413], " +
                "[167.8752929333776, -30.078235509309092]]," +
                "[[167.43638852926597, -29.811913377451322], [167.43642819713568, -29.81191343893342], " +
                "[167.43660948310222, -29.684470839430233], [167.43638852926597, -29.811913377451322]], " +
                "[[167.2900169281376, -29.811700260790584], [167.29007609051774, -29.811700416752192], " +
                "[167.29022481985885, -29.765019899914726], [167.2900169281376, -29.811700260790584]], " +
                "[[167.72865676499967, -29.812149953736277], [167.7287401903084, -29.81214997654223], [167.72874, -29.812], " +
                "[167.72893197342373, -29.81199982820994], [167.72851531939722, -29.568503012044204], " +
                "[167.72851327553326, -29.56850301862287], [167.72865676499967, -29.812149953736277]], " +
                "[[167.87424106545097, -29.302014822030415], [167.87432742269175, -29.30201461402921], " +
                "[167.87418553426855, -29.265830214765142], [167.87424106545097, -29.302014822030415]], " +
                "[[168.1652103335658, -29.3030088541673], [168.16605788758287, -29.446580625201833], " +
                "[168.16556735186845, -29.303245228857072], [168.165381, -29.303246], [168.16537977124085, -29.303008170411644], " +
                "[168.1652103335658, -29.3030088541673]], " +
                "[[168.02088551865063, -29.647294313012004], [168.02133932508806, -29.811843292379823], " +
                "[168.02135614030843, -29.811843274349446], [168.021356, -29.811809], [168.02162340579383, -29.811807949652078], " +
                "[168.02088551865063, -29.647294313012004]]] }"
        )

        val polygons = Polygon.fromGeoJSON(geoJson)!!
        val result = Tessellator.tessellate(polygons[0], random().nextBoolean())
        kotlin.test.assertEquals(84, result.size)
    }

    @Test
    fun testLUCENE8534() {
        val geoJson = (
            "{\"type\":\"Polygon\",\"coordinates\":[[[168.412605,-32.061828],[168.41260500337557,-32.06164814731918],[168.263154,-32.061754],[168.263074,-31.795333]," +
                "[168.2631866330167,-31.79533292075007],[168.26293615809584,-31.55183198959802],[168.26271862830876,-31.55183199836296]," +
                "[168.26260885857246,-31.79551898342183],[168.262799,-31.795519],[168.262922,-32.061969],[168.113391,-32.061955]," +
                "[168.1136947020627,-31.797506925167987],[168.1134623401242,-31.7975067304478],[168.112867,-32.061933],[167.96342,-32.061572]," +
                "[167.964447,-31.795078],[167.96462554945853,-31.79507843013861],[167.96521264500555,-31.551376165945904],[167.965145,-31.551376]," +
                "[167.9663078329189,-31.287013079577566],[167.966251,-31.287013],[167.9664724470441,-31.186852765132446],[167.966135,-31.286996]," +
                "[167.96583002270634,-31.28699509215832],[167.96514242732414,-31.530648904745615],[167.96518,-31.530649],[167.964244373485,-31.795342905910022]," +
                "[167.964267,-31.795343],[167.963051,-32.06191],[167.813527,-32.061286],[167.81515841152935,-31.796764131690956],[167.815107,-31.796764]," +
                "[167.8163675951437,-31.55101526478777],[167.81635023954297,-31.551015225373174],[167.814827,-31.796834],[167.81479823247224,-31.796833898826222]," +
                "[167.813495,-32.061159],[167.664068,-32.060513],[167.66581,-31.794011],[167.6658519100183,-31.794011179736117],[167.6677495759609,-31.550438401064135]," +
                "[167.667432,-31.550437],[167.66930180157829,-31.286073839134556],[167.669105,-31.286073],[167.670807,-31.019532],[167.818843,-31.020159]," +
                "[167.8175723936035,-31.284543327213736],[167.81766095836642,-31.284543526532044],[167.818971,-31.020062],[167.967033,-31.020499]," +
                "[167.96703262843647,-31.020609267886275],[168.114968,-31.020815],[168.1149445990616,-31.05814524188174],[168.114978,-31.020912],[168.26306,-31.021035]," +
                "[168.2631849793437,-31.203987591682104],[168.263163,-31.021002],[168.411259,-31.020914],[168.41125954741193,-31.02123593258559]," +
                "[168.5589863328454,-31.020786105561243],[168.558986,-31.020705],[168.707027,-31.020199],[168.70828992266655,-31.242361611483734]," +
                "[168.707298,-31.020426],[168.855538,-31.019789],[168.85713808565947,-31.284233200286536],[168.857209,-31.284233]," +
                "[168.8583969293829,-31.54547348363567],[168.86057,-31.796021],[168.86004803213373,-31.796023826818654],[168.862202,-32.060514]," +
                "[168.712722,-32.061376],[168.71099229524427,-31.796760977737968],[168.7108263042178,-31.79676167516991],[168.712468,-32.061301]," +
                "[168.56291,-32.061787],[168.561684,-31.795261],[168.56198761104602,-31.795260018704994],[168.560821,-31.530975]," +
                "[168.56092374559077,-31.530974570518158],[168.56001677082173,-31.287057906497665],[168.5597021283975,-31.287058866102726]," +
                "[168.5607530382453,-31.530880020491022],[168.560769,-31.53088],[168.56079128925168,-31.539754620482725],[168.560842,-31.55152]," +
                "[168.56082083893278,-31.551520031401303],[168.56143311036655,-31.7953001584517],[168.561622,-31.7953],[168.562045,-32.0617],[168.412605,-32.061828]]," +
                "[[168.41212499436773,-31.68171617103951],[168.41200593405762,-31.551740860609502],[168.411912,-31.551741],[168.41154546767467,-31.416898111348704]," +
                "[168.41158059852074,-31.53102923335134],[168.411729,-31.531029],[168.41212499436773,-31.68171617103951]]," +
                "[[168.7083938476212,-31.28652950649234],[168.70945084576658,-31.485690997091577],[168.70886199577689,-31.28667838236468],[168.708488,-31.28668]," +
                "[168.7084873259438,-31.28652918474386],[168.7083938476212,-31.28652950649234]]," +
                "[[168.71121460687698,-31.795031659971823],[168.71136127361123,-31.79503081865431],[168.71038567290682,-31.657182838382653],[168.71121460687698,-31.795031659971823]]," +
                "[[167.81624041598312,-31.53023516975434],[167.81634270442586,-31.530235525706665],[167.81676369867318,-31.434841665952604],[167.81624041598312,-31.53023516975434]]]}"
        )

        val polygons = Polygon.fromGeoJSON(geoJson)!!
        val result = Tessellator.tessellate(polygons[0], random().nextBoolean())
        kotlin.test.assertEquals(113, result.size)
    }

    @Test
    fun testInvalidPolygonIntersects() {
        val wkt = "POLYGON((0 0, 1 1, 0 1, 1 0, 0 0))"
        val polygon = SimpleWKTShapeParser.parse(wkt)

        run {
            val ex = expectThrows(IllegalArgumentException::class) {
                Tessellator.tessellate(polygon, true)
            }
            kotlin.test.assertEquals(
                "Polygon self-intersection at lat=0.5 lon=0.5",
                ex!!.message
            )
        }
        run {
            val ex = expectThrows(IllegalArgumentException::class) {
                Tessellator.tessellate(polygon, false)
            }
            kotlin.test.assertEquals(
                "Unable to Tessellate shape. Possible malformed shape detected.",
                ex!!.message
            )
        }
    }

    @Test
    fun testInvalidPolygonOverlap() {
        val wkt = (
            "POLYGON((6.0373903 52.0927095, 6.0363363 52.0924929, 6.0364421 52.0925414, " +
                "6.0366551 52.0927136, 6.0367463 52.092781, 6.0370682 52.0929958, 6.0372052 52.093085, " +
                "6.0373191 52.0931397, 6.037441 52.0931853, 6.0387158 52.0935294, 6.0388509 52.093564, " +
                "6.0388904 52.093572, 6.03894 52.0935172, 6.0389929 52.093481, 6.0390607 52.0934904, " +
                "6.0395233 52.0936092, 6.0397184 52.0936688, 6.0398596 52.0937371, 6.0399905 52.0938164, " +
                "6.0401399 52.0939142, 6.0402279 52.0939553, 6.0403145 52.0939837, 6.0405561 52.0940279, " +
                "6.0437818 52.0947554, 6.043835 52.0947734, 6.0438704 52.0947948, 6.0438877 52.0948026, " +
                "6.0439294 52.0948214, 6.0440239 52.0948431, 6.0440735 52.0948507, 6.0441791 52.0948543, " +
                "6.045512 52.0947949, 6.0455192 52.0948216, 6.0456981 52.0947986, 6.0459013 52.0947863, " +
                "6.0460089 52.0947857, 6.0461408 52.0948108, 6.0462669 52.0948578, 6.0463578 52.0949239, " +
                "6.0463764 52.0949825, 6.0463582 52.0950124, 6.0463968 52.0950234, 6.0463915 52.0950928, " +
                "6.0473354 52.0963349, 6.0485817 52.0963608, 6.0490603 52.0962177, 6.0489671 52.0960387, " +
                "6.0462486 52.0946473, 6.0438777 52.094124, 6.0425991 52.0938519, 6.0415155 52.0936271, " +
                "6.0413498 52.093569, 6.040999 52.0934704, 6.0406499 52.0933945, 6.040265 52.0933135, " +
                "6.0401695 52.0926941, 6.0401431 52.092505, 6.0393746 52.0924531, 6.0392555 52.0924338, " +
                "6.039146 52.0923841, 6.0390625 52.0923275, 6.0389748 52.0922443, 6.0378985 52.0913116, " +
                "6.0376887 52.0914018, 6.0375636 52.0914061, 6.037535 52.0914026, 6.037483 52.0913363, " +
                "6.0374139 52.0912876, 6.037277 52.0912639, 6.0370897 52.091257, 6.0370336 52.0913821, " +
                "6.0368773 52.0915326, 6.0366141 52.0917119, 6.0361993 52.091979, 6.0360755 52.0920244, " +
                "6.0360358 52.0920367, 6.0359538 52.0920908, 6.035886 52.0921313, 6.0358394 52.0921889, " +
                "6.0358354 52.0922414, 6.035836 52.0922822, 6.0358481 52.0923161, 6.0358538 52.0923315, " +
                "6.0358873 52.0923605, 6.0376211 52.0927082, 6.0379741 52.0927953, 6.0379461 52.0928399, " +
                "6.0376294 52.0927647, 6.0373903 52.0927095), (6.0391557 52.0929189, 6.0388667 52.0928373, " +
                "6.0387045 52.0928107, 6.038578 52.0927855, 6.0384897 52.0927195, 6.0384626 52.0927036, " +
                "6.0384412 52.0926911, 6.0382642 52.0926086, 6.0380309 52.092529, 6.0377877 52.0924683, " +
                "6.0377571 52.0924499, 6.0377263 52.0924189, 6.037857 52.0923747, 6.0383203 52.0923097, " +
                "6.0385012 52.0922528, 6.0385416 52.0922588, 6.0385632 52.0923458, 6.0386452 52.0924386, " +
                "6.0387875 52.0925001, 6.0391495 52.0926998, 6.0393437 52.0928496, 6.0393774 52.0928918, " +
                "6.0393715 52.092914, 6.0393239 52.0929308, 6.039246 52.0929349, 6.0391557 52.0929189), " +
                "(6.0377263 52.0924189, 6.0377571 52.0924499, 6.0377877 52.0924683, 6.0380309 52.092529, " +
                "6.0382642 52.0926086, 6.0384412 52.0926911, 6.0384626 52.0927036, 6.0384897 52.0927195, " +
                "6.038578 52.0927855, 6.0387045 52.0928107, 6.0388667 52.0928373, 6.0391557 52.0929189, " +
                "6.039246 52.0929349, 6.0393239 52.0929308, 6.0393715 52.092914, 6.0393774 52.0928918, " +
                "6.0393437 52.0928496, 6.0391495 52.0926998, 6.0387875 52.0925001, 6.0386452 52.0924386, " +
                "6.0385632 52.0923458, 6.0385416 52.0922588, 6.0385012 52.0922528, 6.0383203 52.0923097, " +
                "6.037857 52.0923747, 6.0377263 52.0924189))"
        )
        val polygon = SimpleWKTShapeParser.parse(wkt)
        run {
            val ex = expectThrows(IllegalArgumentException::class) { Tessellator.tessellate(polygon, true) }
            assertEquals("Polygon ring self-intersection at lat=52.0924189 lon=6.0377263", ex!!.message)
        }
        run {
            val ex = expectThrows(IllegalArgumentException::class) { Tessellator.tessellate(polygon, false) }
            assertEquals("Unable to Tessellate shape. Possible malformed shape detected.", ex!!.message)
        }
    }

    @Test
    fun testLUCENE8559() {
        val wkt = "POLYGON((-0.1348674 51.7458255,-0.1345884 51.7455067,-0.1329898 51.745314,-0.1326358 51.745314,-0.1324105 51.744404,-0.131981 51.7444423,-0.1312196 51.7445102,-0.1310908 51.7456794,-0.1319706 51.7460713,-0.1343095 51.7465828,-0.1348674 51.7458255),(-0.1322388 51.7447959,-0.1322388 51.7454336,-0.1318633 51.7457126,-0.1313912 51.7456262,-0.1318985 51.7448032,-0.1322388 51.7447959))"
        checkPolygon(wkt)
    }

    @Test
    fun testLUCENE8556() {
        val wkt = (
            "POLYGON((-111.4765 68.321,-111.47625 68.32225,-111.4765 68.3225,-111.478 68.3225,-111.47825 68.32275,-111.479 68.32275,-111.47975 68.32325,-111.48125 68.324,-111.4815 68.32375,-111.48175 68.32375," +
                "-111.48225 68.32425,-111.48275 68.32425,-111.483 68.324,-111.4845 68.324,-111.48475 68.32425,-111.4845 68.32475,-111.48425 68.3245,-111.483 68.325,-111.4835 68.325,-111.48425 68.3255,-111.48525 68.3255,-111.4855 68.32575," +
                "-111.4855 68.32525,-111.486 68.32475,-111.48725 68.3245,-111.4875 68.32475,-111.48725 68.325,-111.487 68.325,-111.4865 68.32525,-111.487 68.32575,-111.486465 68.326385,-111.486 68.326,-111.48575 68.32625," +
                "-111.48525 68.32625,-111.485 68.326,-111.48375 68.326,-111.48225 68.3265,-111.483 68.3265,-111.48325 68.32675,-111.4835 68.3265,-111.48675 68.3265,-111.487 68.32675,-111.48675 68.32725,-111.4865 68.327," +
                "-111.48375 68.32775,-111.485 68.32775,-111.48525 68.3275,-111.4855 68.3275,-111.486 68.32775,-111.48625 68.3275,-111.48675 68.3275,-111.48725 68.327,-111.48775 68.327,-111.4875 68.32625,-111.488 68.32625," +
                "-111.48825 68.32675,-111.49025 68.327,-111.49025 68.32675,-111.4905 68.3265,-111.49075 68.3265,-111.49125 68.326,-111.492 68.32575,-111.4945 68.32575,-111.49475 68.3255,-111.49525 68.3255,-111.4955 68.32525,-111.49625 68.32525," +
                "-111.4965 68.325,-111.49775 68.32425,-111.498 68.3245,-111.4985 68.3245,-111.49875 68.32425,-111.49925 68.32425,-111.5005 68.324,-111.50075 68.32375,-111.501 68.32375,-111.501 68.323,-111.5015 68.323,-111.50175 68.32325,-111.5015 68.3235," +
                "-111.5025 68.32375,-111.50275 68.3235,-111.504 68.32375,-111.50425 68.3235,-111.50525 68.32325,-111.5055 68.3235,-111.506 68.3235,-111.50625 68.32325,-111.5065 68.3225,-111.5075 68.3225,-111.50775 68.32275,-111.50825 68.32275," +
                "-111.5085 68.3225,-111.50875 68.3225,-111.509 68.32275,-111.5125 68.32275,-111.51325 68.32225,-111.4765 68.321))"
        )
        checkPolygon(wkt)
    }

    @Test
    fun testInvalidPolygonCollinear() {
        val wkt = "POLYGON ((18.9401790919516 -33.9681188869036, 18.9401790919516 -33.9681188869036, 18.9401790919517 -33.9681188869036, 18.9401790919517 -33.9681188869036, 18.9401790919516 -33.9681188869036))"
        val polygon = SimpleWKTShapeParser.parse(wkt)
        val ex = expectThrows(IllegalArgumentException::class) { Tessellator.tessellate(polygon, true) }
        assertEquals("at least three non-collinear points required", ex!!.message)
    }

    @Test
    fun testComplexPolygon01() {
        val wkt = (
            "POLYGON((58.8792517 54.9160937, 58.8762477 54.9154524, 58.8735011 54.9140217, 58.8726428 54.9127389, 58.8731146 54.9122507, 58.8741877 54.9120482, 58.8771918 54.9117028, 58.88011 54.913331, 58.8801175 54.9137036, 58.8805885 54.9143186, 58.8807109 54.9148604, 58.88011 54.915551, 58.8792517 54.9160937)," +
                "(58.8746003 54.9125589, 58.8766188 54.9137965, 58.8791419 54.9152275, 58.8798554 54.9151074, 58.8805548 54.9146087, 58.8801175 54.9137036, 58.8788867 54.9130833, 58.8790905 54.9128921, 58.8767533 54.9120561, 58.8748358 54.9122495, 58.8744557 54.9124049, 58.8746003 54.9125589))"
        )
        checkPolygon(wkt)
    }

    @Test
    fun testComplexPolygon02() {
        val wkt = (
            "POLYGON((-0.5033651 48.7307175, -0.5036334 48.7300183, -0.5038592 48.7297349, -0.5044826 48.7295356, -0.5049852 48.72953, -0.504857 48.7301383, -0.5041382 48.7310084, -0.5033651 48.7307175)," +
                "(-0.504035 48.730838, -0.504282 48.730519, -0.504718 48.729958, -0.504778 48.72988, -0.504545 48.729797, -0.50448 48.729774, -0.503721 48.73073, -0.504035 48.730838)," +
                "(-0.50448 48.729774, -0.504545 48.729797, -0.504708 48.729597, -0.50458 48.729554, -0.504419 48.729753, -0.50448 48.729774))"
        )
        checkPolygon(wkt)
    }

    @Test
    fun testComplexPolygon03() {
        val wkt = (
            "POLYGON((57.7258102 -20.1927474, 57.7257611 -20.192854, 57.7260971 -20.1929559, 57.726191 -20.1929232, 57.7262648 -20.1926211, 57.7262165 -20.1925544,57.7260649 -20.1924877, 57.7259684 -20.1924678, 57.7259333 -20.1925297, 57.7258102 -20.1927474)," +
                " (57.7259333 -20.1925297, 57.7258471 -20.1927671, 57.7259774 -20.1928078, 57.7260433 -20.1925557, 57.7259333 -20.1925297))"
        )
        checkPolygon(wkt)
    }

    @Test
    fun testComplexPolygon04() {
        val wkt = (
            "POLYGON((139.2749646 36.2742799, 139.2747468 36.2743137, 139.2747057 36.2743705, 139.2745531 36.2743918, 139.2744944 36.2743563, 139.2719227 36.2747799, 139.2719021 36.2748249, 139.2723724 36.2762706, 139.2724692 36.2765445, 139.2725362 36.2765573, 139.2754328 36.2760613, 139.2749646 36.2742799)," +
                "(139.2726473 36.2762561, 139.2726277 36.2760151, 139.2723528 36.2760297, 139.2723724 36.2762706, 139.2726473 36.2762561))"
        )
        checkPolygon(wkt)
    }

    @Test
    fun testComplexPolygon05() {
        val wkt = (
            "POLYGON((8.6778468 49.8622443, 8.6782001 49.8622443, 8.6786272 49.8622443, 8.6790127 49.8622444, 8.6790127 49.8620355, 8.678775 49.8620355, 8.6780348 49.8620354, 8.6778468 49.8620354, 8.6778468 49.8622443)," +
                " (8.6785777 49.8621738, 8.6785775 49.8620923, 8.678253 49.8620926, 8.6782532 49.8621741, 8.6785777 49.8621738)," +
                " (8.6781491 49.8621742, 8.6781491 49.8620925, 8.6779802 49.8620925, 8.6779802 49.8621742, 8.6781491 49.8621742))"
        )
        checkPolygon(wkt)
    }

    @Test
    fun testComplexPolygon06() {
        val wkt = (
            "POLYGON((-77.578272 38.7906104, -77.5784061 38.7901379, -77.5785349 38.7897198, -77.5786743 38.7894522, -77.5787441 38.7892306, -77.578846 38.7891679," +
                " -77.5789104 38.7891762, -77.5789747 38.789239, -77.5789747 38.7893979, -77.5789694 38.789586, -77.5789104 38.7897449, -77.5789104 38.7898494," +
                " -77.5789104 38.7900083, -77.5789157 38.7901714, -77.5789157 38.7903052, -77.5790659 38.7903972, -77.5791786 38.7905101, -77.5792215 38.7905979," +
                " -77.5789962 38.7906439, -77.5787977 38.7905268, -77.5786529 38.7904724, -77.5785027 38.7905352, -77.578272 38.7906104))"
        )
        checkPolygon(wkt)
    }

    // helper functions ported from Java
    private fun checkPolygon(wkt: String) {
        val polygon = SimpleWKTShapeParser.parse(wkt)
        checkPolygon(polygon, 0.0)
    }

    private fun checkPolygon(polygon: Polygon, delta: Double) {
        val tessellation = Tessellator.tessellate(polygon, random().nextBoolean())
        assertEquals(area(polygon), area(tessellation), delta)
        for (t in tessellation) {
            checkTriangleEdgesFromPolygon(polygon, t)
        }
    }

    private fun checkTriangleEdgesFromPolygon(p: Polygon, t: Tessellator.Triangle) {
        assertEquals(t.isEdgefromPolygon(0), isEdgeFromPolygon(p, t.getX(0), t.getY(0), t.getX(1), t.getY(1)))
        assertEquals(t.isEdgefromPolygon(1), isEdgeFromPolygon(p, t.getX(1), t.getY(1), t.getX(2), t.getY(2)))
        assertEquals(t.isEdgefromPolygon(2), isEdgeFromPolygon(p, t.getX(2), t.getY(2), t.getX(0), t.getY(0)))
    }

    private fun area(p: Polygon): Double {
        var acc = 0.0
        for (i in 0 until p.numPoints() - 1) {
            acc += p.getPolyLon(i) * p.getPolyLat(i + 1) - p.getPolyLat(i) * p.getPolyLon(i + 1)
        }
        var area = abs(acc / 2.0)
        for (hole in p.getHoles()) {
            area -= area(hole)
        }
        return area
    }

    private fun area(triangles: List<Tessellator.Triangle>): Double {
        var area = 0.0
        for (t in triangles) {
            val lats = doubleArrayOf(t.getY(0), t.getY(1), t.getY(2), t.getY(0))
            val lons = doubleArrayOf(t.getX(0), t.getX(1), t.getX(2), t.getX(0))
            area += area(Polygon(lats, lons))
        }
        return area
    }

    private fun isEdgeFromPolygon(p: Polygon, aLon: Double, aLat: Double, bLon: Double, bLat: Double): Boolean {
        for (i in 0 until p.getPolyLats().size - 1) {
            if (isPointInLine(p.getPolyLon(i), p.getPolyLat(i), p.getPolyLon(i + 1), p.getPolyLat(i + 1), aLon, aLat) &&
                isPointInLine(p.getPolyLon(i), p.getPolyLat(i), p.getPolyLon(i + 1), p.getPolyLat(i + 1), bLon, bLat)
            ) {
                return true
            }
            if (p.getPolyLon(i) != p.getPolyLon(i + 1) || p.getPolyLat(i) != p.getPolyLat(i + 1)) {
                val length = p.getPolyLats().size
                val offset = i + 2
                var j = 0
                var index = getIndex(length, j + offset)
                while (j < length && area(p.getPolyLon(i), p.getPolyLat(i), p.getPolyLon(i + 1), p.getPolyLat(i + 1), p.getPolyLon(index), p.getPolyLat(index)) == 0.0) {
                    if (isPointInLine(p.getPolyLon(i), p.getPolyLat(i), p.getPolyLon(index), p.getPolyLat(index), aLon, aLat) &&
                        isPointInLine(p.getPolyLon(i), p.getPolyLat(i), p.getPolyLon(index), p.getPolyLat(index), bLon, bLat)
                    ) {
                        return true
                    }
                    index = getIndex(length, ++j + offset)
                }
            }
        }
        for (hole in p.getHoles()) {
            if (isEdgeFromPolygon(hole, aLon, aLat, bLon, bLat)) {
                return true
            }
        }
        return false
    }

    private fun getIndex(size: Int, index: Int): Int = if (index < size) index else index - size

    private fun area(aX: Double, aY: Double, bX: Double, bY: Double, cX: Double, cY: Double): Double {
        return (bY - aY) * (cX - bX) - (bX - aX) * (cY - bY)
    }

    private fun isPointInLine(aX: Double, aY: Double, bX: Double, bY: Double, lon: Double, lat: Double): Boolean {
        val dxc = lon - aX
        val dyc = lat - aY
        val dxl = bX - aX
        val dyl = bY - aY
        if (dxc * dyl - dyc * dxl == 0.0) {
            return if (abs(dxl) >= abs(dyl)) {
                if (dxl > 0) aX <= lon && lon <= bX else bX <= lon && lon <= aX
            } else {
                if (dyl > 0) aY <= lat && lat <= bY else bY <= lat && lat <= aY
            }
        }
        return false
    }
}
