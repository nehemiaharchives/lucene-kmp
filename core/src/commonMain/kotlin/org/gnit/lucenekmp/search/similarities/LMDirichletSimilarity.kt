package org.gnit.lucenekmp.search.similarities

import org.gnit.lucenekmp.jdkport.isFinite
import org.gnit.lucenekmp.search.Explanation
import kotlin.math.ln


/**
 * Bayesian smoothing using Dirichlet priors. From Chengxiang Zhai and John Lafferty. 2001. A study
 * of smoothing methods for language models applied to Ad Hoc information retrieval. In Proceedings
 * of the 24th annual international ACM SIGIR conference on Research and development in information
 * retrieval (SIGIR '01). ACM, New York, NY, USA, 334-342.
 *
 *
 * The formula as defined the paper assigns a negative score to documents that contain the term,
 * but with fewer occurrences than predicted by the collection language model. The Lucene
 * implementation returns `0` for such documents.
 *
 * @lucene.experimental
 */
class LMDirichletSimilarity : LMSimilarity {
    /** Returns the  parameter.  */
    /** The  parameter.  */
    val mu: Float

    /** Instantiates the similarity with the provided  parameter.  */
    /** Instantiates the similarity with the default  value of 2000.  */
    constructor(
        collectionModel: CollectionModel,
        mu: Float = 2000f
    ) : this(collectionModel, true, mu)

    /** Instantiates the similarity with the provided parameters.  */
    constructor(
        collectionModel: CollectionModel,
        discountOverlaps: Boolean,
        mu: Float
    ) : super(collectionModel, discountOverlaps) {
        require(!(Float.isFinite(mu) == false || mu < 0)) { "illegal mu value: $mu, must be a non-negative finite value" }
        this.mu = mu
    }

    /** Instantiates the similarity with the provided  parameter.  */
    /** Instantiates the similarity with the default  value of 2000.  */
    constructor(mu: Float = 2000f) {
        require(!(Float.isFinite(mu) == false || mu < 0)) { "illegal mu value: $mu, must be a non-negative finite value" }
        this.mu = mu
    }

    override fun score(
        stats: BasicStats,
        freq: Double,
        docLen: Double
    ): Double {
        val score: Double =
            (stats.boost
                    * (ln(1 + freq / (mu * (stats as LMStats).collectionProbability)) + ln(
                mu / (docLen + mu)
            )))
        return if (score > 0.0) score else 0.0
    }

    override fun explain(
        subs: MutableList<Explanation>,
        stats: BasicStats,
        freq: Double,
        docLen: Double
    ) {
        if (stats.boost != 1.0) {
            subs.add(
                Explanation.match(
                    stats.boost.toFloat(),
                    "query boost"
                )
            )
        }
        val p: Double =
            (stats as LMStats).collectionProbability
        val explP: Explanation =
            Explanation.match(
                p.toFloat(), "P, probability that the current term is generated by the collection"
            )
        val explFreq: Explanation =
            Explanation.match(
                freq.toFloat(),
                "freq, number of occurrences of term in the document"
            )

        subs.add(Explanation.match(mu, "mu"))
        val weightExpl: Explanation =
            Explanation.match(
                ln(1 + freq / (mu * stats.collectionProbability)).toFloat(),
                "term weight, computed as log(1 + freq /(mu * P)) from:",
                explFreq,
                explP
            )
        subs.add(weightExpl)
        subs.add(
            Explanation.match(
                ln(mu / (docLen + mu)).toFloat(),
                "document norm, computed as log(mu / (dl + mu))"
            )
        )
        subs.add(
            Explanation.match(
                docLen.toFloat(),
                "dl, length of field"
            )
        )
        super.explain(subs, stats, freq, docLen)
    }

    override fun explain(
        stats: BasicStats,
        freq: Explanation,
        docLen: Double
    ): Explanation {
        val subs: MutableList<Explanation> = mutableListOf()
        explain(subs, stats, freq.value.toDouble(), docLen)

        return Explanation.match(
            score(stats, freq.value.toDouble(), docLen).toFloat(),
            ("score("
                    + this::class.simpleName
                    + ", freq="
                    + freq.value
                    + "), computed as boost * "
                    + "(term weight + document norm) from:"),
            subs
        )
    }

    override val name: String
        get() = "Dirichlet(${this.mu})"
}
